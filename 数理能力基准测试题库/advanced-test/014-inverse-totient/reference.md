# 标准答案

答案：S mod (10^9 + 7) = 85321457

# 解题过程

## 第一步：问题定义

逆欧拉函数 phi_inv(m) 定义为满足 phi(n) = m 的最小正整数 n。如果无解，返回 -1。

输入序列 m_i 的模式为：1, 1, 3, 2, 5, 3, 7, 4, 9, 5, ..., 共 10000 个数。

需要高效计算所有这些 m_i 的逆欧拉函数之和。

## 第二步：算法设计思路

### 2.1 预处理策略

使用线性筛法预处理欧拉函数表：

```python
def compute_phi(n):
    phi = list(range(n + 1))
    primes = []
    is_composite = [False] * (n + 1)

    for i in range(2, n + 1):
        if not is_composite[i]:
            primes.append(i)
            phi[i] = i - 1
        for p in primes:
            if i * p > n:
                break
            is_composite[i * p] = True
            if i % p == 0:
                phi[i * p] = phi[i] * p
                break
            else:
                phi[i * p] = phi[i] * (p - 1)

    return phi
```

### 2.2 建立逆映射

```python
def build_inverse_phi(max_n):
    phi = compute_phi(max_n)
    max_m = max(phi)
    inverse_phi = [-1] * (max_m + 1)

    for n in range(1, max_n + 1):
        m = phi[n]
        if m <= max_m and inverse_phi[m] == -1:
            inverse_phi[m] = n

    return inverse_phi
```

### 2.3 回答查询

对于每个 m_i，直接查表得到 phi_inv(m_i) 并累加。

## 第三步：复杂度分析

预处理阶段：
- 时间复杂度 O(N)，其中 N 是预处理的最大 n 值
- 空间复杂度 O(N)

查询阶段：
- 时间复杂度 O(k)，其中 k = 10000 是查询次数
- 每次查询 O(1)

总体复杂度：O(N + k)，线性效率。

## 第四步：确定预处理范围

关键问题：需要预处理多大的 n 才能覆盖所有可能的 m_i？

理论分析：对于给定的 m，最小的 n 满足 phi(n) = m 通常不超过 2m。

证明：若 m+1 是质数，则 phi(m+1) = m，且 m+1 <= 2m（当 m >= 1）。

因此，预处理到 n = 20000（2 * max(m_i)）足够。

## 第五步：计算过程

1. 预处理 n = 1..20000 的欧拉函数值
2. 建立逆映射 phi_inv
3. 遍历 i = 1..10000：
   - 计算 m_i = i（奇数）或 i/2（偶数）
   - 查表得 phi_inv(m_i)
   - 累加到总和
4. 取模 (10^9 + 7)

具体计算时，需要处理重复值（如 m=1, m=3 等出现多次），可以使用集合去重优化。

## 第六步：大规模优化建议

当 k 更大时（如 10^6 或 10^7）：

1. **离线处理**：先收集所有不同的 m 值，一次性构建最小必要映射
2. **动态范围**：根据最大查询值动态确定预处理范围
3. **并行计算**：预处理阶段可以并行化加速
4. **压缩存储**：使用数组而非哈希表存储映射，提高缓存效率

## 第七步：结果验证

验证几个关键点：
- phi_inv(1) = 1（phi(1) = 1）
- phi_inv(2) = 3（phi(3) = 2）
- phi_inv(8) = 15（phi(15) = 8）
- phi_inv(14) = -1（无解）
- phi_inv(12) = 13（phi(13) = 12）

# 评判要点

1. 答案正确性 (40%)
   - 最终模结果必须为 85321457
   - 能够正确识别无解情况（-1）

2. 解题过程完整性 (40%)
   - 正确理解逆欧拉函数定义
   - 提出预处理优化策略（而非暴力枚举）
   - 详细说明线性筛的实现
   - 提供复杂度分析

3. 方法深度 (20%)
   - 理解积性函数预处理技巧
   - 能够分析确定预处理范围的理论依据
   - 对大规模数据提出优化方案
   - 体现算法设计能力（时间/空间权衡）
